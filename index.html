<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>AR Hand Controller 3D - Casa 3D</title>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: #1e1e1e;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            position: fixed;
            touch-action: none;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
            overflow: hidden;
        }

        #input_video {
            display: none;
        }

        #webgl_canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            z-index: 2;
        }

        #hand_canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            z-index: 3;
        }

        .instructions {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 6px;
            color: #ccc;
            font-size: 11px;
            z-index: 10;
            text-align: center;
            max-width: 95%;
            line-height: 1.3;
        }

        .gesture-info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 6px;
            z-index: 10;
            font-size: 10px;
            line-height: 1.4;
            max-width: 60%;
        }

        .gesture-info h3 {
            margin: 0 0 5px 0;
            color: #4CAF50;
            font-size: 12px;
        }

        .gesture-item {
            margin: 3px 0;
            padding-left: 5px;
            font-size: 9px;
        }

        #loadingMsg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            border-radius: 8px;
            font-size: 13px;
            text-align: center;
            max-width: 80%;
        }

        .status-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 6px;
            z-index: 10;
            font-size: 9px;
        }

        .hand-status {
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 2px 0;
        }

        .indicator-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #555;
            flex-shrink: 0;
        }

        .indicator-dot.active {
            background: #4CAF50;
            box-shadow: 0 0 8px #4CAF50;
        }

        #cameraButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            z-index: 101;
            display: none;
        }

        #cameraButton:hover {
            background: #45a049;
        }

        @media (min-width: 768px) {
            .gesture-info {
                padding: 12px 15px;
                font-size: 12px;
                max-width: 50%;
            }
            .gesture-info h3 {
                font-size: 15px;
            }
            .gesture-item {
                font-size: 11px;
            }
            .instructions {
                font-size: 13px;
                padding: 12px 20px;
            }
        }

        @media (min-width: 1024px) {
            .container {
                max-width: 1280px;
                max-height: 720px;
                margin: auto;
                border-radius: 12px;
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            }
            body {
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .gesture-info {
                padding: 15px;
                font-size: 13px;
                top: 20px;
                left: 20px;
            }
            .gesture-info h3 {
                font-size: 16px;
            }
            .gesture-item {
                font-size: 12px;
                margin: 5px 0;
                padding-left: 10px;
            }
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div class="container">
        <div id="loadingMsg">Cargando casa 3D y IA...</div>
        <button id="cameraButton">Permitir C√°mara</button>

        <div class="gesture-info">
            <h3>üéÆ Controles</h3>
            <div class="gesture-item">ü§è <strong>Der:</strong> Rotar</div>
            <div class="gesture-item">ü§è <strong>Izq:</strong> Mover</div>
            <div class="gesture-item">ü§èü§è <strong>Ambas:</strong> Zoom</div>
            <div class="gesture-item">‚úãü§è <strong>D+I:</strong> Mover parte</div>
        </div>

        <div class="status-indicator">
            <div class="hand-status">
                <div id="leftDot" class="indicator-dot"></div>
                <span id="leftStatus">Izq: --</span>
            </div>
            <div class="hand-status">
                <div id="rightDot" class="indicator-dot"></div>
                <span id="rightStatus">Der: --</span>
            </div>
        </div>

        <video id="input_video" playsinline></video>
        <canvas id="webgl_canvas"></canvas>
        <canvas id="hand_canvas"></canvas>

        <div id="instructions" class="instructions">Usa tus manos para controlar la casa 3D</div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const loadingMsg = document.getElementById('loadingMsg');
        const cameraButton = document.getElementById('cameraButton');
        const webglCanvas = document.getElementById('webgl_canvas');
        const handCanvas = document.getElementById('hand_canvas');
        const handCanvasCtx = handCanvas.getContext('2d');
        const instructionsDiv = document.getElementById('instructions');
        const leftDot = document.getElementById('leftDot');
        const rightDot = document.getElementById('rightDot');
        const leftStatus = document.getElementById('leftStatus');
        const rightStatus = document.getElementById('rightStatus');

        let cameraStarted = false;
        let renderer = null;

        function resizeCanvas() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            webglCanvas.width = width;
            webglCanvas.height = height;
            handCanvas.width = width;
            handCanvas.height = height;
            if (renderer) {
                renderer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 100));

        let currentObject = null;
        let scene = new THREE.Scene();
        const INITIAL_SCALE = 2;

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ canvas: webglCanvas, alpha: true, antialias: true });
        renderer.setClearColor(0x000000, 0);

        const light = new THREE.DirectionalLight(0xffffff, 2);
        light.position.set(5, 5, 5);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));
        camera.position.z = 5;

        resizeCanvas();

        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let selectedFace = null;
        let initialFacePosition = new THREE.Vector3();

        function loadHouse3D() {
            if (currentObject) scene.remove(currentObject);
            const group = new THREE.Group();
            const wallMaterial = new THREE.MeshPhongMaterial({ color: 0xF5DEB3, side: THREE.DoubleSide, transparent: true, opacity: 0.95 });
            const roofMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513, side: THREE.DoubleSide, transparent: true, opacity: 0.95 });
            const doorMaterial = new THREE.MeshPhongMaterial({ color: 0x654321, side: THREE.DoubleSide, transparent: true, opacity: 0.95 });
            const windowMaterial = new THREE.MeshPhongMaterial({ color: 0x87CEEB, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
            const chimneyMaterial = new THREE.MeshPhongMaterial({ color: 0xA52A2A, side: THREE.DoubleSide, transparent: true, opacity: 0.95 });
            const wallSize = 2, wallHeight = 1.5, roofHeight = 1;
            const wallGeometry = new THREE.PlaneGeometry(wallSize, wallHeight);
            
            const frontWall = new THREE.Mesh(wallGeometry, wallMaterial.clone());
            frontWall.position.set(0, 0, wallSize/2);
            frontWall.userData.isFace = true;
            frontWall.add(new THREE.LineSegments(new THREE.EdgesGeometry(frontWall.geometry), new THREE.LineBasicMaterial({ color: 0xffffff })));
            group.add(frontWall);
            
            const backWall = new THREE.Mesh(wallGeometry, wallMaterial.clone());
            backWall.position.set(0, 0, -wallSize/2);
            backWall.rotation.y = Math.PI;
            backWall.userData.isFace = true;
            backWall.add(new THREE.LineSegments(new THREE.EdgesGeometry(backWall.geometry), new THREE.LineBasicMaterial({ color: 0xffffff })));
            group.add(backWall);
            
            const leftWall = new THREE.Mesh(wallGeometry, wallMaterial.clone());
            leftWall.position.set(-wallSize/2, 0, 0);
            leftWall.rotation.y = -Math.PI/2;
            leftWall.userData.isFace = true;
            leftWall.add(new THREE.LineSegments(new THREE.EdgesGeometry(leftWall.geometry), new THREE.LineBasicMaterial({ color: 0xffffff })));
            group.add(leftWall);
            
            const rightWall = new THREE.Mesh(wallGeometry, wallMaterial.clone());
            rightWall.position.set(wallSize/2, 0, 0);
            rightWall.rotation.y = Math.PI/2;
            rightWall.userData.isFace = true;
            rightWall.add(new THREE.LineSegments(new THREE.EdgesGeometry(rightWall.geometry), new THREE.LineBasicMaterial({ color: 0xffffff })));
            group.add(rightWall);
            
            const roofGeometry = new THREE.PlaneGeometry(wallSize, roofHeight * 1.2);
            const roofLeft = new THREE.Mesh(roofGeometry, roofMaterial.clone());
            roofLeft.position.set(-wallSize/4, wallHeight/2 + roofHeight/3, 0);
            roofLeft.rotation.z = Math.PI / 4;
            roofLeft.userData.isFace = true;
            roofLeft.add(new THREE.LineSegments(new THREE.EdgesGeometry(roofLeft.geometry), new THREE.LineBasicMaterial({ color: 0xffffff })));
            group.add(roofLeft);
            
            const roofRight = new THREE.Mesh(roofGeometry, roofMaterial.clone());
            roofRight.position.set(wallSize/4, wallHeight/2 + roofHeight/3, 0);
            roofRight.rotation.z = -Math.PI / 4;
            roofRight.userData.isFace = true;
            roofRight.add(new THREE.LineSegments(new THREE.EdgesGeometry(roofRight.geometry), new THREE.LineBasicMaterial({ color: 0xffffff })));
            group.add(roofRight);
            
            const doorGeometry = new THREE.PlaneGeometry(0.5, 0.8);
            const door = new THREE.Mesh(doorGeometry, doorMaterial.clone());
            door.position.set(0, -0.35, wallSize/2 + 0.01);
            door.userData.isFace = true;
            door.add(new THREE.LineSegments(new THREE.EdgesGeometry(door.geometry), new THREE.LineBasicMaterial({ color: 0xffffff })));
            group.add(door);
            
            const windowGeometry = new THREE.PlaneGeometry(0.4, 0.4);
            const windows = [
                { pos: [-0.5, 0.2, wallSize/2 + 0.01], rot: [0, 0, 0] },
                { pos: [0.5, 0.2, wallSize/2 + 0.01], rot: [0, 0, 0] },
                { pos: [-wallSize/2 - 0.01, 0.2, 0], rot: [0, -Math.PI/2, 0] },
                { pos: [wallSize/2 + 0.01, 0.2, 0], rot: [0, Math.PI/2, 0] }
            ];
            windows.forEach(w => {
                const win = new THREE.Mesh(windowGeometry, windowMaterial.clone());
                win.position.set(w.pos[0], w.pos[1], w.pos[2]);
                win.rotation.set(w.rot[0], w.rot[1], w.rot[2]);
                win.userData.isFace = true;
                win.add(new THREE.LineSegments(new THREE.EdgesGeometry(win.geometry), new THREE.LineBasicMaterial({ color: 0xffffff })));
                group.add(win);
            });
            
            const chimneyGeometry = new THREE.BoxGeometry(0.3, 0.6, 0.3);
            const chimney = new THREE.Mesh(chimneyGeometry, chimneyMaterial.clone());
            chimney.position.set(0.5, wallHeight/2 + roofHeight/2 + 0.1, 0.3);
            chimney.userData.isFace = true;
            chimney.add(new THREE.LineSegments(new THREE.EdgesGeometry(chimney.geometry), new THREE.LineBasicMaterial({ color: 0xffffff })));
            group.add(chimney);
            
            currentObject = group;
            currentObject.scale.set(INITIAL_SCALE, INITIAL_SCALE, INITIAL_SCALE);
            currentObject.position.set(0, -0.5, 0);
            currentObject.rotation.y = Math.PI;
            scene.add(currentObject);
        }

        loadHouse3D();

        const MEDIA_PIPE_SCALE = 5;
        let isRotating = false, lastRotationX = 0, lastRotationY = 0, lastRotationAngle = 0;
        let targetRotationX = 0, targetRotationY = 0, targetRotationZ = 0;
        let isTranslating = false, isScaling = false, lastScaleDistance = null;
        let isMovingFace = false, lastFacePinchX = 0, lastFacePinchY = 0;
        const ROTATION_FACTOR = 2.5, ROTATION_Z_FACTOR = 1.5, ROTATION_SMOOTHING = 0.15;
        const POSITION_SMOOTHING = 0.15, SCALE_SENSITIVITY = 15.0, FACE_MOVEMENT_SMOOTHING = 0.25;

        function calculateDistance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }
        function calculateAngle(x1, y1, x2, y2) {
            return Math.atan2(y2 - y1, x2 - x1);
        }
        function normalizeTo3D(normalizedX, normalizedY) {
            return { x: normalizedX * MEDIA_PIPE_SCALE - (MEDIA_PIPE_SCALE / 2), y: -(normalizedY * MEDIA_PIPE_SCALE - (MEDIA_PIPE_SCALE / 2)) };
        }
        function normalizedToCanvas(normalizedX, normalizedY) {
            return { x: (1 - normalizedX) * webglCanvas.width, y: normalizedY * webglCanvas.height };
        }
        function canvasToNormalizedScreen(canvasX, canvasY) {
            return new THREE.Vector2((canvasX / webglCanvas.width) * 2 - 1, -(canvasY / webglCanvas.height) * 2 + 1);
        }

        function handleRotationWithRightHand(indexTip, thumbTip) {
            if (!currentObject) return;
            const pinchX = (indexTip.x + thumbTip.x) / 2, pinchY = (indexTip.y + thumbTip.y) / 2;
            if (!isRotating) {
                isRotating = true;
                lastRotationX = pinchX; lastRotationY = pinchY;
                lastRotationAngle = calculateAngle(indexTip.x, indexTip.y, thumbTip.x, thumbTip.y) * -1;
                targetRotationX = currentObject.rotation.x; targetRotationY = currentObject.rotation.y; targetRotationZ = currentObject.rotation.z;
            } else {
                const deltaX = pinchX - lastRotationX, deltaY = pinchY - lastRotationY;
                const currentAngle = calculateAngle(indexTip.x, indexTip.y, thumbTip.x, thumbTip.y) * -1;
                targetRotationY += deltaX * ROTATION_FACTOR; targetRotationX += deltaY * ROTATION_FACTOR;
                let angleDelta = currentAngle - lastRotationAngle;
                if (angleDelta > Math.PI) angleDelta -= 2 * Math.PI;
                else if (angleDelta < -Math.PI) angleDelta += 2 * Math.PI;
                targetRotationZ += angleDelta * ROTATION_Z_FACTOR * 0.3;
                lastRotationX = pinchX; lastRotationY = pinchY; lastRotationAngle = currentAngle;
            }
            currentObject.rotation.x += (targetRotationX - currentObject.rotation.x) * ROTATION_SMOOTHING;
            currentObject.rotation.y += (targetRotationY - currentObject.rotation.y) * ROTATION_SMOOTHING;
            currentObject.rotation.z += (targetRotationZ - currentObject.rotation.z) * ROTATION_SMOOTHING;
        }

        function handleTranslationWithLeftHand(indexTip, thumbTip) {
            if (!currentObject) return;
            const pinch3D = normalizeTo3D((indexTip.x + thumbTip.x) / 2, (indexTip.y + thumbTip.y) / 2);
            currentObject.position.x += (pinch3D.x - currentObject.position.x) * POSITION_SMOOTHING;
            currentObject.position.y += (pinch3D.y - currentObject.position.y) * POSITION_SMOOTHING;
        }

        function handleScaleWithBothHands(leftPinch, rightPinch) {
            if (!currentObject) return;
            const distance = calculateDistance(leftPinch.x, leftPinch.y, rightPinch.x, rightPinch.y);
            if (lastScaleDistance !== null) {
                const deltaDistance = distance - lastScaleDistance;
                let newScale = Math.max(0.5, Math.min(15, currentObject.scale.x + deltaDistance * SCALE_SENSITIVITY));
                const smoothing = 0.3;
                currentObject.scale.x += (newScale - currentObject.scale.x) * smoothing;
                currentObject.scale.y += (newScale - currentObject.scale.y) * smoothing;
                currentObject.scale.z += (newScale - currentObject.scale.z) * smoothing;
            }
            lastScaleDistance = distance;
        }

        function handleFaceMovementLeftPinch(indexTip, thumbTip, isPinching) {
            if (!currentObject) return;
            const pinchX = (indexTip.x + thumbTip.x) / 2, pinchY = (indexTip.y + thumbTip.y) / 2;
            const pinch3D = normalizeTo3D(pinchX, pinchY);
            if (isPinching && !selectedFace && !isMovingFace) {
                const pinchCanvas = normalizedToCanvas(pinchX, pinchY);
                mouse = canvasToNormalizedScreen(pinchCanvas.x, pinchCanvas.y);
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(currentObject.children.filter(obj => obj.userData.isFace), false);
                if (intersects.length > 0) {
                    selectedFace = intersects[0].object;
                    selectedFace.material.emissive.setHex(0x555555);
                    initialFacePosition.copy(selectedFace.position);
                    lastFacePinchX = pinch3D.x; lastFacePinchY = pinch3D.y;
                    isMovingFace = true;
                }
            } else if (isPinching && selectedFace && isMovingFace) {
                const deltaX = pinch3D.x - lastFacePinchX, deltaY = pinch3D.y - lastFacePinchY;
                const worldMovement = new THREE.Vector3(deltaX, deltaY, 0);
                const localMovement = worldMovement.clone();
                localMovement.applyQuaternion(currentObject.quaternion.clone().invert());
                selectedFace.position.x += localMovement.x * FACE_MOVEMENT_SMOOTHING;
                selectedFace.position.y += localMovement.y * FACE_MOVEMENT_SMOOTHING;
                selectedFace.position.z += localMovement.z * FACE_MOVEMENT_SMOOTHING;
                lastFacePinchX = pinch3D.x; lastFacePinchY = pinch3D.y;
            } else if (!isPinching && selectedFace) {
                selectedFace.material.emissive.setHex(0x000000);
                selectedFace = null; isMovingFace = false;
            }
        }

        function onResults(results) {
            if (loadingMsg.style.display !== 'none' && currentObject) loadingMsg.style.display = 'none';
            handCanvasCtx.save();
            handCanvasCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);
            const handsData = [];
            if (results.multiHandLandmarks && results.multiHandedness) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const handedness = results.multiHandedness[i].label;
                    const indexTip = landmarks[8], thumbTip = landmarks[4];
                    const middleTip = landmarks[12], ringTip = landmarks[16], pinkyTip = landmarks[20];
                    const isPinching = calculateDistance(indexTip.x, indexTip.y, thumbTip.x, thumbTip.y) < 0.10;
                    const indexMCP = landmarks[5], middleMCP = landmarks[9], ringMCP = landmarks[13], pinkyMCP = landmarks[17];
                    const isOpen = calculateDistance(indexMCP.x, indexMCP.y, indexTip.x, indexTip.y) > 0.12 &&
                                   calculateDistance(middleMCP.x, middleMCP.y, middleTip.x, middleTip.y) > 0.12 &&
                                   calculateDistance(ringMCP.x, ringMCP.y, ringTip.x, ringTip.y) > 0.10 &&
                                   calculateDistance(pinkyMCP.x, pinkyMCP.y, pinkyTip.x, pinkyTip.y) > 0.10 && !isPinching;
                    handsData.push({ handedness, landmarks, indexTip, thumbTip, isPinching, isOpen, pinchX: (indexTip.x + thumbTip.x) / 2, pinchY: (indexTip.y + thumbTip.y) / 2 });
                    drawConnectors(handCanvasCtx, landmarks, HAND_CONNECTIONS, { color: handedness === 'Right' ? '#00CC00' : '#0099FF', lineWidth: 2 });
                    drawLandmarks(handCanvasCtx, landmarks, { color: isPinching ? '#FF0000' : '#FFFF00', lineWidth: 1 });
                }
            }
            const leftHand = handsData.find(h => h.handedness === 'Left');
            const rightHand = handsData.find(h => h.handedness === 'Right');
            if (leftHand) {
                leftDot.classList.add('active');
                leftStatus.textContent = leftHand.isPinching ? 'Izq: ü§è' : (leftHand.isOpen ? 'Izq: ‚úã' : 'Izq: üëä');
            } else {
                leftDot.classList.remove('active');
                leftStatus.textContent = 'Izq: --';
            }
            if (rightHand) {
                rightDot.classList.add('active');
                rightStatus.textContent = rightHand.isPinching ? 'Der: ü§è' : (rightHand.isOpen ? 'Der: ‚úã' : 'Der: üëä');
            } else {
                rightDot.classList.remove('active');
                rightStatus.textContent = 'Der: --';
            }
            let currentAction = 'Esperando gestos...';
            if (rightHand && rightHand.isOpen && leftHand && leftHand.isPinching) {
                handleFaceMovementLeftPinch(leftHand.indexTip, leftHand.thumbTip, true);
                currentAction = '‚úãü§è MOVER PARTE';
                isRotating = false; isTranslating = false; lastScaleDistance = null;
            } else if (leftHand && rightHand && leftHand.isPinching && rightHand.isPinching) {
                handleScaleWithBothHands({ x: leftHand.pinchX, y: leftHand.pinchY }, { x: rightHand.pinchX, y: rightHand.pinchY });
                currentAction = 'ü§èü§è ZOOM';
                isRotating = false; isTranslating = false;
                if (selectedFace) { selectedFace.material.emissive.setHex(0x000000); selectedFace = null; isMovingFace = false; }
            } else if (rightHand && rightHand.isPinching && (!leftHand || !leftHand.isPinching)) {
                handleRotationWithRightHand(rightHand.indexTip, rightHand.thumbTip);
                currentAction = 'ü§è ROTANDO';
                isTranslating = false; lastScaleDistance = null;
                if (selectedFace) { selectedFace.material.emissive.setHex(0x000000); selectedFace = null; isMovingFace = false; }
            } else if (leftHand && leftHand.isPinching && (!rightHand || !rightHand.isPinching)) {
                handleTranslationWithLeftHand(leftHand.indexTip, leftHand.thumbTip);
                currentAction = 'ü§è TRASLADANDO';
                isRotating = false; lastScaleDistance = null;
                if (selectedFace) { selectedFace.material.emissive.setHex(0x000000); selectedFace = null; isMovingFace = false; }
            } else {
                isRotating = false; isTranslating = false; lastScaleDistance = null;
                if (selectedFace) { selectedFace.material.emissive.setHex(0x000000); selectedFace = null; isMovingFace = false; }
            }
            instructionsDiv.innerHTML = currentAction;
            if (currentObject) renderer.render(scene, camera);
            handCanvasCtx.restore();
        }

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(onResults);

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'user',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                videoElement.srcObject = stream;
                videoElement.addEventListener('loadeddata', () => {
                    const cameraFeed = new Camera(videoElement, {
                        onFrame: async () => {
                            await hands.send({ image: videoElement });
                        },
                        width: 1280,
                        height: 720
                    });
                    cameraFeed.start();
                    cameraStarted = true;
                    loadingMsg.textContent = 'Cargando modelo de IA...';
                    setTimeout(() => {
                        if (currentObject) loadingMsg.style.display = 'none';
                    }, 2000);
                });
            } catch (error) {
                console.error('Error al acceder a la c√°mara:', error);
                loadingMsg.innerHTML = '‚ùå Error al acceder a la c√°mara.<br>Por favor permite el acceso en la configuraci√≥n del navegador.';
                cameraButton.style.display = 'block';
                cameraButton.textContent = 'Reintentar C√°mara';
            }
        }

        cameraButton.addEventListener('click', () => {
            cameraButton.style.display = 'none';
            loadingMsg.textContent = 'Accediendo a la c√°mara...';
            loadingMsg.style.display = 'block';
            startCamera();
        });

        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            startCamera();
        } else {
            loadingMsg.innerHTML = '‚ùå Tu navegador no soporta acceso a la c√°mara.';
            cameraButton.style.display = 'block';
            cameraButton.textContent = 'Navegador no compatible';
            cameraButton.disabled = true;
        }
    </script>
</body>
</html>
