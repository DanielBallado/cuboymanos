<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>AR Hand Controller 3D - M√≥vil</title>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: #1e1e1e;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            position: fixed;
            touch-action: none;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
            overflow: hidden;
        }

        #input_video {
            display: none;
        }

        #webgl_canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            z-index: 2;
        }

        #hand_canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            z-index: 3;
        }

        .instructions {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 6px;
            color: #ccc;
            font-size: 11px;
            z-index: 10;
            text-align: center;
            max-width: 95%;
            line-height: 1.3;
        }

        .gesture-info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 6px;
            z-index: 10;
            font-size: 10px;
            line-height: 1.4;
            max-width: 60%;
        }

        .gesture-info h3 {
            margin: 0 0 5px 0;
            color: #4CAF50;
            font-size: 12px;
        }

        .gesture-item {
            margin: 3px 0;
            padding-left: 5px;
            font-size: 9px;
        }

        #loadingMsg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 20px;
            border-radius: 8px;
            pointer-events: none;
            font-size: 13px;
            text-align: center;
            max-width: 80%;
        }

        .status-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 6px;
            z-index: 10;
            font-size: 9px;
        }

        .hand-status {
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 2px 0;
        }

        .indicator-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #555;
            flex-shrink: 0;
        }

        .indicator-dot.active {
            background: #4CAF50;
            box-shadow: 0 0 8px #4CAF50;
        }

        /* Landscape optimization */
        @media (orientation: landscape) {
            .gesture-info {
                font-size: 11px;
                max-width: 40%;
            }

            .gesture-info h3 {
                font-size: 13px;
            }

            .gesture-item {
                font-size: 10px;
            }

            .instructions {
                font-size: 12px;
                padding: 10px 15px;
            }

            .status-indicator {
                font-size: 10px;
                padding: 8px 12px;
            }
        }

        /* Tablet optimization */
        @media (min-width: 768px) {
            .gesture-info {
                padding: 12px 15px;
                font-size: 12px;
                max-width: 50%;
            }

            .gesture-info h3 {
                font-size: 15px;
                margin-bottom: 8px;
            }

            .gesture-item {
                font-size: 11px;
                margin: 4px 0;
            }

            .instructions {
                font-size: 13px;
                padding: 12px 20px;
                bottom: 15px;
            }

            .status-indicator {
                font-size: 11px;
                padding: 8px 12px;
            }

            .indicator-dot {
                width: 9px;
                height: 9px;
            }
        }

        /* Desktop fallback */
        @media (min-width: 1024px) {
            .container {
                max-width: 1280px;
                max-height: 720px;
                margin: auto;
                border-radius: 12px;
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            }

            body {
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .gesture-info {
                padding: 15px;
                font-size: 13px;
                top: 20px;
                left: 20px;
            }

            .gesture-info h3 {
                font-size: 16px;
            }

            .gesture-item {
                font-size: 12px;
                margin: 5px 0;
                padding-left: 10px;
            }

            .instructions {
                font-size: 14px;
                padding: 15px 25px;
                bottom: 20px;
            }

            .status-indicator {
                font-size: 12px;
                padding: 10px 15px;
                top: 20px;
                right: 20px;
            }

            .indicator-dot {
                width: 10px;
                height: 10px;
            }
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>

    <div class="container">
        <div id="loadingMsg">Cargando cubo 3D y IA...<br>Por favor permite el acceso a la c√°mara.</div>

        <div class="gesture-info">
            <h3>üéÆ Controles</h3>
            <div class="gesture-item">ü§è <strong>Der:</strong> Rotar objeto</div>
            <div class="gesture-item">ü§è <strong>Izq:</strong> Trasladar</div>
            <div class="gesture-item">ü§èü§è <strong>Ambas:</strong> Zoom</div>
            <div class="gesture-item">‚úãü§è <strong>D+I:</strong> Mover cara</div>
        </div>

        <div class="status-indicator">
            <div class="hand-status">
                <div id="leftDot" class="indicator-dot"></div>
                <span id="leftStatus">Izq: --</span>
            </div>
            <div class="hand-status">
                <div id="rightDot" class="indicator-dot"></div>
                <span id="rightStatus">Der: --</span>
            </div>
        </div>

        <video id="input_video"></video>
        <canvas id="webgl_canvas"></canvas>
        <canvas id="hand_canvas"></canvas>

        <div id="instructions" class="instructions">
            Usa tus manos para controlar el cubo 3D
        </div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const loadingMsg = document.getElementById('loadingMsg');
        const webglCanvas = document.getElementById('webgl_canvas');
        const handCanvas = document.getElementById('hand_canvas');
        const handCanvasCtx = handCanvas.getContext('2d');
        const instructionsDiv = document.getElementById('instructions');

        // Indicadores de estado
        const leftDot = document.getElementById('leftDot');
        const rightDot = document.getElementById('rightDot');
        const leftStatus = document.getElementById('leftStatus');
        const rightStatus = document.getElementById('rightStatus');

        // Resize canvas responsivamente
        function resizeCanvas() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            webglCanvas.width = width;
            webglCanvas.height = height;
            handCanvas.width = width;
            handCanvas.height = height;

            if (renderer) {
                renderer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100);
        });

        // --- SETUP DE THREE.JS ---
        let currentObject = null;
        let scene = new THREE.Scene();
        const INITIAL_SCALE = 3;

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({
            canvas: webglCanvas,
            alpha: true,
            antialias: true
        });

        renderer.setClearColor(0x000000, 0);

        const light = new THREE.DirectionalLight(0xffffff, 2);
        light.position.set(5, 5, 5);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));
        camera.position.z = 5;

        resizeCanvas();

        // Variables para raycasting (mover cara)
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let selectedFace = null;
        let initialFacePosition = new THREE.Vector3();

        // --- CONSTRUIR CUBO ---
        function loadComposedCube() {
            if (currentObject) {
                scene.remove(currentObject);
                currentObject = null;
            }

            loadingMsg.style.display = 'block';
            loadingMsg.innerHTML = `Construyendo cubo 3D...`;

            const cubeSize = 1;
            const halfSize = cubeSize / 2;

            const baseMaterial = new THREE.MeshPhongMaterial({
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });

            const faceDefinitions = [
                { pos: [halfSize, 0, 0], rot: [0, Math.PI / 2, 0], color: 0xFF0000 },
                { pos: [-halfSize, 0, 0], rot: [0, -Math.PI / 2, 0], color: 0x00FF00 },
                { pos: [0, halfSize, 0], rot: [-Math.PI / 2, 0, 0], color: 0x0000FF },
                { pos: [0, -halfSize, 0], rot: [Math.PI / 2, 0, 0], color: 0xFFFF00 },
                { pos: [0, 0, halfSize], rot: [0, 0, 0], color: 0xFF00FF },
                { pos: [0, 0, -halfSize], rot: [0, Math.PI, 0], color: 0x00FFFF }
            ];

            const group = new THREE.Group();
            const planeGeometry = new THREE.PlaneGeometry(cubeSize, cubeSize);

            faceDefinitions.forEach(def => {
                const faceMaterial = baseMaterial.clone();
                faceMaterial.color.setHex(def.color);

                const faceMesh = new THREE.Mesh(planeGeometry, faceMaterial);
                faceMesh.position.set(def.pos[0], def.pos[1], def.pos[2]);
                faceMesh.rotation.set(def.rot[0], def.rot[1], def.rot[2]);
                faceMesh.userData.isFace = true;

                faceMesh.add(new THREE.LineSegments(
                    new THREE.EdgesGeometry(faceMesh.geometry),
                    new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 })
                ));

                group.add(faceMesh);
            });

            currentObject = group;
            currentObject.scale.set(INITIAL_SCALE, INITIAL_SCALE, INITIAL_SCALE);
            currentObject.position.set(0, -0.5, 0);
            currentObject.rotation.y = Math.PI;
            scene.add(currentObject);

            loadingMsg.style.display = 'none';
        }

        loadComposedCube();

        // --- VARIABLES DE CONTROL ---
        const MEDIA_PIPE_SCALE = 5;

        // Para rotaci√≥n (mano derecha)
        let isRotating = false;
        let lastRotationX = 0;
        let lastRotationY = 0;
        let lastRotationAngle = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let targetRotationZ = 0;

        // Para traslaci√≥n (mano izquierda)
        let isTranslating = false;

        // Para escala (ambas manos)
        let isScaling = false;
        let lastScaleDistance = null;

        // Para mover cara (mano izquierda)
        let isMovingFace = false;
        let lastFacePinchX = 0;
        let lastFacePinchY = 0;

        // Factores de sensibilidad
        const ROTATION_FACTOR = 2.5;
        const ROTATION_Z_FACTOR = 1.5;
        const ROTATION_SMOOTHING = 0.15;
        const POSITION_SMOOTHING = 0.15;
        const SCALE_SENSITIVITY = 15.0;
        const FACE_MOVEMENT_SMOOTHING = 0.25;

        // --- FUNCIONES AUXILIARES ---
        function calculateDistance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        function calculateAngle(x1, y1, x2, y2) {
            return Math.atan2(y2 - y1, x2 - x1);
        }

        function normalizeTo3D(normalizedX, normalizedY) {
            const x3D = normalizedX * MEDIA_PIPE_SCALE - (MEDIA_PIPE_SCALE / 2);
            const y3D = -(normalizedY * MEDIA_PIPE_SCALE - (MEDIA_PIPE_SCALE / 2));
            return { x: x3D, y: y3D };
        }

        function normalizedToCanvas(normalizedX, normalizedY) {
            const x = (1 - normalizedX) * webglCanvas.width;
            const y = normalizedY * webglCanvas.height;
            return { x: x, y: y };
        }

        function canvasToNormalizedScreen(canvasX, canvasY) {
            const x = (canvasX / webglCanvas.width) * 2 - 1;
            const y = -(canvasY / webglCanvas.height) * 2 + 1;
            return new THREE.Vector2(x, y);
        }

        // --- L√ìGICA DE CONTROL CON DOS MANOS ---

        function handleRotationWithRightHand(indexTip, thumbTip) {
            if (!currentObject) return;

            const pinchX = (indexTip.x + thumbTip.x) / 2;
            const pinchY = (indexTip.y + thumbTip.y) / 2;

            if (!isRotating) {
                isRotating = true;
                lastRotationX = pinchX;
                lastRotationY = pinchY;
                lastRotationAngle = calculateAngle(indexTip.x, indexTip.y, thumbTip.x, thumbTip.y) * -1;

                targetRotationX = currentObject.rotation.x;
                targetRotationY = currentObject.rotation.y;
                targetRotationZ = currentObject.rotation.z;
            } else {
                const deltaX = pinchX - lastRotationX;
                const deltaY = pinchY - lastRotationY;
                const currentAngle = calculateAngle(indexTip.x, indexTip.y, thumbTip.x, thumbTip.y) * -1;

                targetRotationY += deltaX * ROTATION_FACTOR;
                targetRotationX += deltaY * ROTATION_FACTOR;

                let angleDelta = currentAngle - lastRotationAngle;
                if (angleDelta > Math.PI) angleDelta -= 2 * Math.PI;
                else if (angleDelta < -Math.PI) angleDelta += 2 * Math.PI;
                targetRotationZ += angleDelta * ROTATION_Z_FACTOR * 0.3;

                lastRotationX = pinchX;
                lastRotationY = pinchY;
                lastRotationAngle = currentAngle;
            }

            currentObject.rotation.x += (targetRotationX - currentObject.rotation.x) * ROTATION_SMOOTHING;
            currentObject.rotation.y += (targetRotationY - currentObject.rotation.y) * ROTATION_SMOOTHING;
            currentObject.rotation.z += (targetRotationZ - currentObject.rotation.z) * ROTATION_SMOOTHING;
        }

        function handleTranslationWithLeftHand(indexTip, thumbTip) {
            if (!currentObject) return;

            const pinchX = (indexTip.x + thumbTip.x) / 2;
            const pinchY = (indexTip.y + thumbTip.y) / 2;
            const pinch3D = normalizeTo3D(pinchX, pinchY);

            currentObject.position.x += (pinch3D.x - currentObject.position.x) * POSITION_SMOOTHING;
            currentObject.position.y += (pinch3D.y - currentObject.position.y) * POSITION_SMOOTHING;
        }

        function handleScaleWithBothHands(leftPinch, rightPinch) {
            if (!currentObject) return;

            const distance = calculateDistance(leftPinch.x, leftPinch.y, rightPinch.x, rightPinch.y);

            if (lastScaleDistance !== null) {
                const deltaDistance = distance - lastScaleDistance;
                let currentScale = currentObject.scale.x;
                let newScale = currentScale + deltaDistance * SCALE_SENSITIVITY;
                newScale = Math.max(0.5, Math.min(15, newScale));

                const smoothing = 0.3;
                currentObject.scale.x += (newScale - currentObject.scale.x) * smoothing;
                currentObject.scale.y += (newScale - currentObject.scale.y) * smoothing;
                currentObject.scale.z += (newScale - currentObject.scale.z) * smoothing;
            }

            lastScaleDistance = distance;
        }

        function handleFaceMovementLeftPinch(indexTip, thumbTip, isPinching) {
            if (!currentObject) return;

            const pinchX = (indexTip.x + thumbTip.x) / 2;
            const pinchY = (indexTip.y + thumbTip.y) / 2;
            const pinch3D = normalizeTo3D(pinchX, pinchY);

            if (isPinching && !selectedFace && !isMovingFace) {
                const pinchCanvas = normalizedToCanvas(pinchX, pinchY);
                mouse = canvasToNormalizedScreen(pinchCanvas.x, pinchCanvas.y);
                raycaster.setFromCamera(mouse, camera);

                const intersectableObjects = currentObject.children.filter(obj => obj.userData.isFace);
                const intersects = raycaster.intersectObjects(intersectableObjects, false);

                if (intersects.length > 0) {
                    selectedFace = intersects[0].object;
                    selectedFace.material.emissive.setHex(0x555555);

                    initialFacePosition.copy(selectedFace.position);
                    lastFacePinchX = pinch3D.x;
                    lastFacePinchY = pinch3D.y;

                    isMovingFace = true;
                }
            }
            else if (isPinching && selectedFace && isMovingFace) {
                const deltaX = pinch3D.x - lastFacePinchX;
                const deltaY = pinch3D.y - lastFacePinchY;

                const worldMovement = new THREE.Vector3(deltaX, deltaY, 0);
                const localMovement = worldMovement.clone();
                localMovement.applyQuaternion(currentObject.quaternion.clone().invert());

                selectedFace.position.x += localMovement.x * FACE_MOVEMENT_SMOOTHING;
                selectedFace.position.y += localMovement.y * FACE_MOVEMENT_SMOOTHING;
                selectedFace.position.z += localMovement.z * FACE_MOVEMENT_SMOOTHING;

                lastFacePinchX = pinch3D.x;
                lastFacePinchY = pinch3D.y;
            }
            else if (!isPinching && selectedFace) {
                selectedFace.material.emissive.setHex(0x000000);
                selectedFace = null;
                isMovingFace = false;
            }
        }

        // --- FUNCI√ìN PRINCIPAL DE MEDIAPIPE ---
        function onResults(results) {
            if (loadingMsg.style.display !== 'none' && !loadingMsg.innerHTML.includes('Error') && currentObject) {
                loadingMsg.style.display = 'none';
            }

            handCanvasCtx.save();
            handCanvasCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);

            const handsData = [];

            if (results.multiHandLandmarks && results.multiHandedness) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const handedness = results.multiHandedness[i].label;

                    const indexTip = landmarks[8];
                    const thumbTip = landmarks[4];
                    const middleTip = landmarks[12];
                    const ringTip = landmarks[16];
                    const pinkyTip = landmarks[20];

                    const pinchDistance = calculateDistance(indexTip.x, indexTip.y, thumbTip.x, thumbTip.y);
                    const isPinching = pinchDistance < 0.10;

                    const indexMCP = landmarks[5];
                    const middleMCP = landmarks[9];
                    const ringMCP = landmarks[13];
                    const pinkyMCP = landmarks[17];

                    const indexExtended = calculateDistance(indexMCP.x, indexMCP.y, indexTip.x, indexTip.y) > 0.12;
                    const middleExtended = calculateDistance(middleMCP.x, middleMCP.y, middleTip.x, middleTip.y) > 0.12;
                    const ringExtended = calculateDistance(ringMCP.x, ringMCP.y, ringTip.x, ringTip.y) > 0.10;
                    const pinkyExtended = calculateDistance(pinkyMCP.x, pinkyMCP.y, pinkyTip.x, pinkyTip.y) > 0.10;

                    const isOpen = indexExtended && middleExtended && ringExtended && pinkyExtended && !isPinching;

                    handsData.push({
                        handedness: handedness,
                        landmarks: landmarks,
                        indexTip: indexTip,
                        thumbTip: thumbTip,
                        isPinching: isPinching,
                        isOpen: isOpen,
                        pinchX: (indexTip.x + thumbTip.x) / 2,
                        pinchY: (indexTip.y + thumbTip.y) / 2
                    });

                    drawConnectors(handCanvasCtx, landmarks, HAND_CONNECTIONS, {
                        color: handedness === 'Right' ? '#00CC00' : '#0099FF',
                        lineWidth: 2
                    });
                    drawLandmarks(handCanvasCtx, landmarks, {
                        color: isPinching ? '#FF0000' : '#FFFF00',
                        lineWidth: 1
                    });
                }
            }

            const leftHand = handsData.find(h => h.handedness === 'Left');
            const rightHand = handsData.find(h => h.handedness === 'Right');

            // Actualizar indicadores de estado
            if (leftHand) {
                leftDot.classList.add('active');
                if (leftHand.isPinching) {
                    leftStatus.textContent = 'Izq: ü§è';
                } else if (leftHand.isOpen) {
                    leftStatus.textContent = 'Izq: ‚úã';
                } else {
                    leftStatus.textContent = 'Izq: üëä';
                }
            } else {
                leftDot.classList.remove('active');
                leftStatus.textContent = 'Izq: --';
            }

            if (rightHand) {
                rightDot.classList.add('active');
                if (rightHand.isPinching) {
                    rightStatus.textContent = 'Der: ü§è';
                } else if (rightHand.isOpen) {
                    rightStatus.textContent = 'Der: ‚úã';
                } else {
                    rightStatus.textContent = 'Der: üëä';
                }
            } else {
                rightDot.classList.remove('active');
                rightStatus.textContent = 'Der: --';
            }

            // L√ìGICA DE CONTROL
            let currentAction = 'Esperando gestos...';

            if (rightHand && rightHand.isOpen && leftHand && leftHand.isPinching) {
                handleFaceMovementLeftPinch(leftHand.indexTip, leftHand.thumbTip, true);
                currentAction = '‚úãü§è MOVER CARA';
                isRotating = false;
                isTranslating = false;
                lastScaleDistance = null;
            }
            else if (leftHand && rightHand && leftHand.isPinching && rightHand.isPinching) {
                handleScaleWithBothHands(
                    { x: leftHand.pinchX, y: leftHand.pinchY },
                    { x: rightHand.pinchX, y: rightHand.pinchY }
                );
                currentAction = 'ü§èü§è ZOOM';
                isRotating = false;
                isTranslating = false;

                if (selectedFace) {
                    selectedFace.material.emissive.setHex(0x000000);
                    selectedFace = null;
                    isMovingFace = false;
                }
            }
            else if (rightHand && rightHand.isPinching && (!leftHand || !leftHand.isPinching)) {
                handleRotationWithRightHand(rightHand.indexTip, rightHand.thumbTip);
                currentAction = 'ü§è ROTANDO';
                isTranslating = false;
                lastScaleDistance = null;

                if (selectedFace) {
                    selectedFace.material.emissive.setHex(0x000000);
                    selectedFace = null;
                    isMovingFace = false;
                }
            }
            else if (leftHand && leftHand.isPinching && (!rightHand || !rightHand.isPinching)) {
                handleTranslationWithLeftHand(leftHand.indexTip, leftHand.thumbTip);
                currentAction = 'ü§è TRASLADANDO';
                isRotating = false;
                lastScaleDistance = null;

                if (selectedFace) {
                    selectedFace.material.emissive.setHex(0x000000);
                    selectedFace = null;
                    isMovingFace = false;
                }
            }
            else {
                isRotating = false;
                isTranslating = false;
                lastScaleDistance = null;

                if (selectedFace) {
                    selectedFace.material.emissive.setHex(0x000000);
                    selectedFace = null;
                    isMovingFace = false;
                }
            }

            instructionsDiv.innerHTML = currentAction;

            if (currentObject) {
                renderer.render(scene, camera);
            }
            handCanvasCtx.restore();
        }

        // --- CONFIGURACI√ìN E INICIO DE MEDIAPIPE ---
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: window.innerWidth,
            height: window.innerHeight
        });

        try {
            cameraFeed.start();
        } catch (error) {
            let errorMsg = "‚ùå Error. Revisa la consola (F12).";
            if (error.name === 'NotAllowedError') {
                errorMsg += " Acceso a la c√°mara DENEGADO.";
            }
            loadingMsg.innerHTML = errorMsg;
            console.error("Error al iniciar MediaPipe/C√°mara:", error);
        }

    </script>
</body>

</html>